global u16 screen_width

include camera
include credits
include debug_mode
include level_layouts
include renderhooks
include resolution
include special_stage
include vram_relocations
include objects/?
include zones/?

////////////////////////////
// Display new resolution //
////////////////////////////

function void ApplyROMManipulations()
{
	base.ApplyROMManipulations()

	ROMManipulation.ScreenHeight()
	ROMManipulation.relocateGameTimeOverVRAMLoc()
}

// We set the screen resolution after the screen has fully faded to black from the previous screen
// but before any object positions, such as those of title card elements, are set.
// Note that special stages handle their own screen size setting in SpecialStage() once the screen is white.
// We also avoid clearing unused.player2.total_rings, which we use for tracking cloud movement in SSZ,
// if we are respawning from the final star post there.
function void initializeMainGame()
{
	global.game_mode |= 0x80
	if (s16(global.rolling_demo) >= 0)
	{
		playSound(MUSIC_CTRL_FADEOUT)
	}
#if STANDALONE
	// Reset music tempo
	Standalone.setFastMusicFlag(FastMusicFlag.MUSIC_TEMPO, false)
	Standalone.setFastMusicFlag(FastMusicFlag.SUPER_THEME, false)

	// Just to be sure this is not active
	Game.endSkippableCutscene()

	Input.setTouchInputMode(TOUCH_INPUT_MODE_NORMAL_CONTROLS)

#if GAMEAPP
	Game.setUnderwaterAudioEffect(0)
#endif
#endif

	global.pause_disabled = 0
	kosinski.queue_size = 0
	zeroMemory(0xffffff10, 0x1b * 4)
	ClearPatternLoadingQueue()

	if (global.zone_act == 0x0d01)
	{
		// Outro for Sonic/Tails
		FadeScreenToWhiteBlocking()

	#if STANDALONE
		// Avoid some black frames when screen should stay white
		VDP.Config.setActiveDisplay(false)
	#endif
	}
	else if (global.zone_act == 0x1701 && global.in_extra_stage != 0)
	{
		// Hidden Palace when entered through a giant ring
		FadeScreenToWhiteBlocking()

	#if STANDALONE
		// Avoid some black frames when screen should stay white
		VDP.Config.setActiveDisplay(false)
	#endif
	}
	else
	{
		FadeOutScreenBlocking()

	#if STANDALONE
		global.zone_act = Game.onFadedOutLoadingZone(global.zone_act)
	#endif
	}

	#if STANDALONE
	{
		Renderer.resetSprites()

		if (Game.isTimeAttack())
		{
			// Don't use "isMainCharacter" or similar here, it's not initialized yet
			if (global.zone_act == 0x0701 && levelselect.characters != CHARS_KNUCKLES_ALONE)
			{
				// MHZ 2: Start after the initial cutscene
				// TODO: The checkpoint number gets reset to 0 later in initialization again
				//     -> This is fine for Time Attack in MHZ 2, but not in other cases like Time Attack in SSZ
				checkpoint.number = 7
				checkpoint.x = 0x052a
				checkpoint.y = 0x05ac
			}
		}

		if (!Game.getSetting(SETTING_CONTINUE_MUSIC))
		{
			// Stop music
			Audio.stopChannel(0)
		}
	}
	#endif

	if (s16(global.rolling_demo) >= 0)
	{
	#if !STANDALONE
		set_status_register(0x2700)
	#endif
		fn0011ca()
	#if !STANDALONE
		set_status_register(0x2300)
	#endif

		// Set screen resolution
		if (useRSDKheight() && !competition_mode.active)
			Renderer.setScreenSize(screen_width, 240)

		level.framecounter = 0
		if (checkpoint.number != 0)
		{
			if (global.stage_type == 0)
			{
				global.zone_act = checkpoint.zone_act
				global.zone_act.apparent = checkpoint.zone_act.apparent
			}
			else
			{
				global.zone_act = level.backup.zone_act
				global.zone_act.apparent = level.backup.zone_act.apparent
			}
		}

		if (global.zone_act != 0x0401 || checkpoint.number != 6)
		{
			A2 = MainGame.getLevelDataPointer()
			D0 = u8[A2]
			if (D0.u8 != 0)
			{
				requestLoadingPatterns(D0.u8)
			}
		}

		SetGlobalCharacters()

		if (isSonicIntro())
		{
			fillPatternLoadingCues(0x01)
			requestLoadingPatterns(0x0a)
		}
		else if (competition_mode.active)
		{
			D0 = 6
			// It looks like RequestLoadingPatterns() is missing here, but each zone already loads the common sprites, so it would be redundant
		}
		else
		{
			// Load both HUD and common object sprites for main game stages
			if (isMainCharacter(CHARACTER_SONIC))
			{
				// Sonic
				requestLoadingPatterns(0x01)
			}
			else if (isMainCharacter(CHARACTER_TAILS))
			{
				// Tails - or Miles
				requestLoadingPatterns((global.region_code & 0x80) ? 0x07 : 0x52)
			}
			else
			{
				// Must be Knuckles then
				requestLoadingPatterns(0x05)
			}
		}
	}

	zeroMemory(0xffffac00, 0x400)
	zeroMemory(0xffffb000, 0x2000)
	zeroMemory(0xfffff628, 0x16 * 4)
	zeroMemory(0xfffff700, 0x100)
	zeroMemory(0xfffffe6e, 0x13 * 4)
	zeroMemory(0xfffffa80, 0x80)

	fn01aa6e()

	VDP.Config.setVerticalScrolling(false, 0xff)	// Good old horizontal scrolling mode
	VDP.Config.setNameTableBasePlaneA(0xc000)
	VDP.Config.setNameTableBasePlaneB(0xe000)
	VDP.Config.setSpriteAttributeTableBase(0xf800)
	VDP.Config.setPlayfieldSizeInPixels(512, 256)
	VDP.Config.enableHInt(false)
	VDP.Config.setupWindowPlane(false, 0)	// Disable window plane
	VDP.Config.setBackdropColor(0x20)
	VDP.Config.setRenderingModeConfiguration(false)

	if (debug_mode.unlocked && control.pad1.state & CONTROL_A)
	{
		debug_mode.enabled.u8 = true
	}

	if (competition_mode.active)
	{
		u16[0xfffffff6] = 0x4ef9		// Machine code for "jump"
		irq_table.lineupdate = 0x000d10

		VDP.Config.enableHInt(true)
		VDP.Config.setNameTableBasePlaneA(0x8000)
		VDP.Config.setNameTableBasePlaneB(0xa000)
		h_int.configuration = 0x8a6b	// H-INT at 0x6b = 107 (near the vertical screen center)

		if (global.zone == 0x0f)
			VDP.Config.setPlayfieldSizeInPixels(512, 512)
		else
			VDP.Config.setPlayfieldSizeInPixels(1024, 256)
	}
	else
	{
		h_int.configuration = 0x8aff
	}
	Renderer.configureHInt()

	u16[0xfffffb00] = 0
	u32[0xfffffbfc] = 0xfffffb00

	Level.loadPaletteData(isMainCharacter(CHARACTER_KNUCKLES) ? 0x05 : 0x03)	// Character palette
	Level.InitializeWater()

	zeroMemory(0xfffff0a0, 0x60)

	if (level.water_present)
	{
		VDP.Config.enableHInt(true)
	}

	if (s16(global.rolling_demo) >= 0)
	{
		bool isKnucklesIntro = (global.zone_act == 0x0700 && isMainCharacter(CHARACTER_KNUCKLES) && global.lock_on_state != 0 && checkpoint.number == 0)
	#if STANDALONE
		isKnucklesIntro = (Game.getSetting(SETTING_AIZ_INTRO_KNUCKLES) != 0 && global.zone_act == 0x0000 && isMainCharacter(CHARACTER_KNUCKLES) && checkpoint.number == 0 && !Game.isTimeAttack())
	#endif

		u8 musicId
		if (global.zone_act == 0x0001 && checkpoint.number == 3)
		{
			musicId = MUSIC_AIZ1
		}
		else if (isKnucklesIntro)
		{
		#if STANDALONE
			// Enforce S&K version of Knuckles' theme
			Audio.playAudio("1f", AudioContext.CONTEXT_MUSIC)
			musicId = 0
		#else
			musicId = MUSIC_KNUCKLES
		#endif
		}
		else
		{
		#if STANDALONE
			// Check if this is the S/T outro
			if (global.zone_act == 0x0d01)
			{
				playMusic(MUSIC_ENDING)		// Play Sonic 3 credits (instead of Sky Sanctuary)
			}
			else
			{
				// Bug fix for second parts of AIZ 1 and ICZ 1
				musicId = u8[0x005f82 + global.zone * 2 + global.act.apparent]
			}
		#else
			musicId = u8[0x005f82 + global.zone * 2 + global.act]
		#endif
		}

		level.default_music = musicId
		if (musicId != 0)
		{
			playMusic(musicId)
		}

		bool isAnyIntro = false
		if (global.zone_act == 0x0000)
		{
			// Angel Island Act 1
			isAnyIntro = isSonicIntro()
		}
		if (isKnucklesIntro)
		{
			// This loads the critters graphics
		#if !STANDALONE
			set_status_register(0x2700)

			// Use AIZ critters and not the MHZ critters in Knuckles' intro, #contributed by iCloudius
			//  -> Also requires a ROM manipulation, search for the comment above to find that one
			Nemesis.loadDataToVRAM(0x1935a8, 0xb000)
		#else
			Nemesis.loadDataToVRAM(0x1931d6, 0xb000)
		#endif
			Nemesis.loadDataToVRAM(0x193308, 0xb240)

			isAnyIntro = true
		}

		if (!isAnyIntro && global.zone_act != 0x1701 && !level.skip_titlecard)
		{
			// Spawn title card
			u32[0xffffb250] = addressof(TitleCard.Update)

			while (true)
			{
				global.frame_state = 0x0c
				Kosinski.ProcessDecompressionQueue()
				waitForNextFrame()

				UpdateGameObjects()
				RenderSprites()
				LoadRequiredSpritePatterns()
				Kosinski.ProcessModules()
				if (u16[0xffffb298] == 0 && u32[0xfffff680] == 0)
					break
			}
		}

		level.skip_titlecard = false
	#if !STANDALONE
		set_status_register(0x2700)
	#endif
		ResetScoreDisplay()
	#if !STANDALONE
		set_status_register(0x2300)
	#endif
	}

	Level.loadNonfadingPaletteData(0x03)	// Sonic's character palette
	Level.SetupLevelSize()

	UpdateCamera()
	fn007812()
	fn01c2b0()

#if !STANDALONE
	set_status_register(0x2700)
#endif
	InitLevelDisplay()
#if !STANDALONE
	set_status_register(0x2300)
#endif

	fn028c80()
	fn0076a6()
	UpdateWater()

	u16[0xffffff7c] = control.pad2
	control.player1 = 0
	control.tails = 0
	control.pad1 = 0
	control.pad2 = 0
	player1.control_override = 1
	player2.control_override = 1
	global.level_started = 0
	if (level.water_present && global.zone == 0x01)
	{
		u32[0xffffcf82] = 0x01f202
		u32[0xffffb172] = addressof(RunOnWaterHandler.Init)		// HCZ run-on-water handler
		u8[0xffffb172 + 0x2c] = 1
	}
	else if (global.zone == 0x07)
	{
		u32[0xffffb128] = addressof(MHZLeavesEffect.Update)		// MHZ leaves effect
	}

	if (checkpoint.number == 0)
	{
		ring_counter = 0
		timer.alldata = 0
		extra_lives_granted = 0
		ring_counter.player2 = 0
		timer.alldata.player2 = 0
	#if STANDALONE
		if (!Game.getSetting(SETTING_MAINTAIN_SHIELDS))
	#endif
		{
			global.shields_backup_1 = 0
		}

		if (global.zone_act == 0x1600 || global.zone_act == 0x1700)
		{
			global.in_extra_stage = 0
		}
		else if (global.zone < 0x13 || (global.zone > 0x15 && global.zone_act != 0x1701))
		{
			global.shields_backup_2 = 0
			global.in_extra_stage = 0
		}
	}

	global.time_over = 0
	debug_mode.state = 0
	level.restart = 0
#if !STANDALONE
	unused.teleport_timer = 0
	unused.teleport_active = 0
#endif
	player.total_rings = 0
	unused.player2.total_rings = (getScreenHeightExtend() > 0 &&global.zone_act == 0x0a00 && checkpoint.number == 4) ? 2 : 0	// We use this flag in SSZ to scroll clouds correctly
	player.item_count = 0
	unused.player2.item_count = 0
	u16[0xfffffede] = 0
	u8[0xfffffe65] = 0
	super.active = 0
	ResetOscillatingNumbers()

	hud.dirty.score = 0x01
	hud.dirty.rings = 0x01
	hud.dirty.timer = 0x01
	global.level_started = 1

	if (global.zone_act == 0x0d01 || global.zone_act == 0x1701)
	{
		// Special handling for S/T Outro and HPZ emerald cave
		hud.dirty.timer = 0
		global.level_started = 0
	}

	fn0067ee()
	DynamicObjectsLoading()
	UpdateListOfRingsAround()

	fn01cacc()

	UpdateGameObjects()
	RenderSprites()
	LevelTilesAnimation()
	global.demo_countdown = 1800	// 30 seconds
	Level.InitializeWater.Part2()

	zeroMemory(0xfffff0a0, 0x60)

	player1.control_override = 0
	player2.control_override = 0
	fn0075d2()

#if STANDALONE
	// Just in case active display got disabled before (when entering Hidden Palace through a Giant Ring)
	VDP.Config.setActiveDisplay(true)
#endif
}

// Enforce original screen resolution for SEGA and title screens.
//# address-hook(0x003e32) end(0x004342)
function void TitleScreen()
{
	playMusic(MUSIC_CTRL_FADEOUT)
	kosinski.queue_size = 0

	zeroMemory(0xffffff10, 0x6c)
#if GAMEAPP
	// Setup region code according to settings
	global.region_code = Game.getSetting(SETTING_REGION_CODE)
#endif

	ClearPatternLoadingQueue()
	global.zone_act = 0
	FadeOutScreenBlocking()

#if STANDALONE
	u32 ptr = 0x003e32
	zeroMemory(ptr, 8)
#else
	set_status_register(0x2700)
#endif

	// Enforce AIR normal screen resolution after the screen is fully white or black.
	Renderer.setScreenSize(400, 224)

	VDP.Config.enableHInt(false)
	VDP.Config.setNameTableBasePlaneA(0xc000)
	VDP.Config.setNameTableBasePlaneB(0xe000)
	VDP.Config.setPlayfieldSizeInPixels(512, 256)
	VDP.Config.setupWindowPlane(false, 0)			// Disable window plane
	VDP.Config.setVerticalScrolling(false, 0xff)	// Good old horizontal scrolling mode
	VDP.Config.setBackdropColor(0)
	VDP.Config.setRenderingModeConfiguration(false)

	water.fullscreen = 0
	level.water_present = 0

	fn0011ca()

	zeroMemory(0xffffac00, 0x400)
	zeroMemory(0xffffb000, 0x2000)
	zeroMemory(0xfffff700, 0x100)
	zeroMemory(0xffffee00, 0x100)

#if STANDALONE
	Renderer.resetSprites()

	// Move planes a bit to the right
	for (u8 i = 0; i < getScreenHeight(); ++i)
		u32[0xffffe000 + i*4] = getScreenExtend() * 0x10001
#endif

	fn01aa6e()

	zeroMemory(0xfffffc00, 0x100)

	checkpoint.number = 0
	global.stage_type = 0
	debug_mode.state = 0
	global.rolling_demo = 0
	level.palettefx.timer_1 = 0
	competition_mode.active = 0
	global.level_started = 0
	debug_mode.enabled.u8 = 0
	competition_mode.active = 0
	u16[0xffffffe4] = 0
	u16[0xffffffe6] = 0
	bluespheres.minigame_mode = 0
	global.demo_countdown = 359		// 6 seconds (minus one frame)
	u16[0xfffffb00] = 0
	u32[0xfffffbfc] = 0xfffffb00

#if STANDALONE
	if (Game.getSetting(SETTING_TITLE_SCREEN))
#else
	if (global.lock_on_state != 0)
#endif
	{
		// Sonic & Knuckles title screen
		TitleScreen_SK()
		return
	}

	// S3 title screen intro first frame
	Kosinski.decompress(0x350d26, 0xffff0000)	// After this, A1 points to where uncompressed data ends
	updateSpritePattern(0xffff0000, TitleScreen.Intro_Background.targetInVRAM, A1.u16 >> 1)

	Enigma.decompress(0x34f6a0, 0xffff8000, (TitleScreen.Intro_Background.targetInVRAM >> 5))

#if !STANDALONE
	if ((global.region_code & 0x80) == 0)
#endif
	{
		// Hide the trademark symbol
		u32[0xffff83ac] = 0
	}

	copyRectToVRAM(0xffff8000, 0xc000, 0x28, 0x1c)

	copyMemory(0xfffffc80, 0x00460c, 0x20)

	global.demo_countdown = 240		// 4 seconds
	VDP.Config.setActiveDisplay(true)
	Menu.FadeInAfterInit()

#if STANDALONE
	// Stop any music that might be playing or restarting (this can happen after aborting a rolling demo)
	playMusic(MUSIC_CTRL_STOP)
#endif
	playMusic(0xff)

	global.demo_countdown = 180		// 3 seconds
	while (global.demo_countdown != 0)
	{
		global.frame_state = 0x14
		waitForNextFrame()
	@EntryPoint_003fd2:

		if (control.pad1.pressed & CONTROL_START)
			break

	#if STANDALONE
		Renderer.resetSprites()
		Renderer.drawCustomSprite("original_game_by", getScreenWidth() / 2 - 85, 60, 0x00, 0, 0x2000, 0, 96)
	#endif
	}

#if !STANDALONE
	playMusic(0xfe)
#endif

	// While loop: SEGA logo background fade from white to black
	A1 = 0x00459c
	while (true)
	{
		global.frame_state = 0x02
		waitForNextFrame()

		copyMemory(0xfffffc00, A1, 0x0e)
		if (u16[A1] == 0)
			break

		A1 += 0x0e

	#if STANDALONE
		Renderer.resetSprites()
		if (u8[0xfffffc01] & 0x0e)
			Renderer.drawCustomSprite("original_game_by", getScreenWidth() / 2 - 85, 60, 0x00, 0, 0x2000, 0, u16(u8[0xfffffc01] & 0x0e) * 96 / 0x0e)
	#endif
	}

	outro.wait_time = 0
	u16[0xfffff662] = 0
	titleintro.buffer = 0xff
	titleintro.frames = 0
	titleintro.animstep = 1
	D0 = 1
	fn00440c()

	global.demo_countdown = (global.region_code & 0x40) ? 750 : 900		// 12.5 seconds / 15 seconds
#if STANDALONE
	// Slightly increase the wait time until demo starts
	global.demo_countdown += 20
#endif

	Kosinski.addToDecompressionQueue(0x351c86, 0xffff0000)
	playMusic(MUSIC_TITLESCREEN)

	// While loop: Intro sequence with Sonic running towards the camera
	while (true)
	{
		global.frame_state = 0x04
		Kosinski.ProcessDecompressionQueue()

		waitForNextFrame()

	#if STANDALONE
		// Overwrite two frames with custom widescreen versions
		if (titleintro.animstep == 7)
		{
			Renderer.drawCustomSprite("intro_wideframe1", getScreenExtend() - 40, 0, 0x00, 0, 0x5000)
		}
		else if (titleintro.animstep == 8)
		{
			Renderer.drawCustomSprite("intro_wideframe2", getScreenExtend() - 40, 0, 0x00, 0, 0x5000)
		}

		if (control.pad1.pressed)
		{
			u8[ptr] = control.pad1.pressed
			++ptr
		}
	#endif

		fn0043d4()
		UpdateGameObjects()
		RenderSprites()
		LoadRequiredSpritePatterns()

		if (control.pad1.pressed & CONTROL_START)
			break

		if (titleintro.animstep >= 12)
			break
	}

	// White screen
	titleintro.animstep = 12
	fillMemory_u16(0xfffffc00, 0x80, 0x0eee)

#if STANDALONE
	titleintro.frames = 15
	for (u8 k = 0; k < titleintro.frames; ++k)
	{
		global.frame_state = 0x04
		waitForNextFrame()
	}

	// This is to make sure screen stays white in the next frame even if skipping the intro
	VDP.Config.setActiveDisplay(false)
#else
	titleintro.frames = 3
	global.frame_state = 0x04
	waitForNextFrame()
#endif

	// Fill the planes with decompressed screen content
	Kosinski.decompress(0x359fc6, 0xffff0000)	// After this, A1 points to where uncompressed data ends
	updateSpritePattern(0xffff0000, TitleScreen.Intro_Background.targetInVRAM, A1.u16 >> 1)

	Enigma.decompress(0x350018, 0xffff8000, (sprite_attribute.PRIORITY | (TitleScreen.Intro_Background.targetInVRAM >> 5)))
	copyRectToVRAM(0xffff8000, 0xc000, 0x28, 0x1c)

	Enigma.decompress(0x350112, 0xffff8000, (sprite_attribute.PALETTE.LINE2 | (TitleScreen.Intro_Background.targetInVRAM >> 5)))
	copyRectToVRAM(0xffff8000, 0xe000, 0x28, 0x1c)

	global.frame_state = 0x04
	waitForNextFrame()

#if STANDALONE
	VDP.Config.setActiveDisplay(true)
#endif

	copyMemory(0xfffffc80, 0x0047ac, 0x80)

	// Load patterns used in title screen
	{
		// Large banner
		Nemesis.loadDataToVRAM(0x35026c, TitleScreen.Banner.targetInVRAM)

		// Menu options, copyright info
		Nemesis.loadDataToVRAM(0x004d2a, TitleScreen.Menu.targetInVRAM)

		// Wiggling finger, winking eye, twinkle, Tails & Tornado in BG
		Nemesis.loadDataToVRAM(0x2c49cc, TitleScreen.Characters.targetInVRAM)

		// "& Knuckles"
		Nemesis.loadDataToVRAM(0x0d6498, TitleScreen.AndKnucklesTitle.targetInVRAM)
	}

	u32[0xffffb000] = 0x00482c		// Banner ("Sonic 3 - Sonic The Hedgehog")
	u32[0xffffb04a] = 0x004a5c		// Menu items
	u32[0xffffb0de] = 0x004a1e		// Copyright info
	u32[0xffffb128] = 0x004ae4		// Sonic's hand wagging
	u32[0xffffb172] = 0x004b54		// Sonic's eye blinking
	u32[0xffffb1bc] = 0x004bb2		// Tails in the Tornado
	u32[0xffffb206] = 0x00496a		// "& Knuckles" logo append
	titleintro.frames = 0

	#if STANDALONE
		global.whiteflash_timeout = 25
		airHighlightAnimationTimer = 0

		// This is needed for the background to be shown in first frame at all (when VDP sprite rendering seems to be disabled)
		Renderer.resetSprites()
		Renderer.drawCustomSprite("bg_title_screen", getScreenExtend() - 40, 0, 0x00, 0, 0x1100)
	#endif

	while (true)
	{
		global.frame_state = 0x04
		waitForNextFrame()
	@EntryPoint:

		UpdateGameObjects()
		RenderSprites()
		LoadRequiredSpritePatterns()

	#if STANDALONE
		// Allow the player to press Start before the logo animation is finished already; only wait for the short white flash to finish
		if (global.whiteflash_timeout > 0)
			continue
	#else
		if (u32[0xffffb094] == 0)
			continue
	#endif

		if (global.demo_countdown == 0)
			break

		if ((control.pad1.pressed | control.pad2.pressed) & CONTROL_START)
		{
			global.game_mode = 0x0c			// Main Game
			lives_counter = 3
			unused.lives_counter.player2 = 3
			ring_counter = 0
			timer.alldata = 0
			player.score = 0
			ring_counter.player2 = 0
			timer.alldata.player2 = 0
			player2.score = 0
			continues_counter = 0
			player.next_life_score = 5000
			unused.player2.next_life_score = 5000

			playSound(MUSIC_CTRL_FADEOUT)

		#if GAMEAPP
			// In S3AIR, there is no choice, always go to the main menu
			FadeOutScreenBlocking()
			Game.returnToMainMenu()
			Audio.fadeOutChannel(0, 0.25f)	// Do the rest of music fade out relatively quickly
			yieldExecution()

		#else
			D0 = titlescreen.selection
			if (D0.u8 == 0)
			{
				// Data Select
				global.game_mode = 0x4c
			}
			else if (D0.u8 == 1)
			{
				// Competition Mode
				global.game_mode = 0x38
			}
			else
			{
				// Level Select
				global.game_mode = 0x28
			}
		#endif
			return
		}
	}

	// Start rolling demo
	playSound(MUSIC_CTRL_FADEOUT)

	u16[0xffffef7a] = global.demo_number
	D0.u16 = (global.demo_number & 0x07) * 2
	D0.u16 = u16[0x004344 + D0.u16]
	global.zone_act = D0.u16
	global.zone_act.apparent = D0.u16
	checkpoint.zone_act = D0.u16

	++global.demo_number
	if (global.lock_on_state == 0)
	{
		if (global.demo_number == 3)		// Skip Knuckles in MHZ demo
		{
			global.demo_number = 4
		}
		else if (global.demo_number >= 7)	// We've got 7 demos in total
		{
			global.demo_number = 0
		}
	}
	else
	{
		if (global.demo_number >= 3)		// Restrict to first four demos
		{
			global.demo_number = 0
		}
	}

	if (D0.s16 < 0)
	{
		// Blue Spheres rolling demo
		global.game_mode = 0x34		// Special Stage
		global.next_bluespheres = 1
		global.sk_bluespheres = 1
		global.zone = 0x07
		u16[0xffffffb0] = 0
		zeroMemory(0xffffffb2, 7)		// Clear emerald collection states
		u8[0xffffffb3] = 0x02
	}
	else
	{
		// Normal Game rolling demo
		global.game_mode = 0x08
	}

	global.rolling_demo = 1
	lives_counter = 3
	unused.lives_counter.player2 = 3
	ring_counter = 0
	timer.alldata = 0
	player.score = 0
	ring_counter.player2 = 0
	timer.alldata.player2 = 0
	player2.score = 0
	player.next_life_score = 5000
	unused.player2.next_life_score = 5000
}

////////////////////////////////
// Move dynamic objects table //
////////////////////////////////

// Formerly 0xffffe380 .. 0xffffe3ff, now 0x8ae380 .. 0x8ae3ff
// Table of dynamic objects in range
//  - First word ("size") is twice the number of objects in the table
//  - After that, each entry is word per object, telling us the RAM address of a dynamic object (lower u16 part only)
define global.dynamic_objects.size_new	= u16[0x8ae380]
define global.dynamic_objects.size	= u16[0x8ae380] // this would be used by any mods above OriginsScreenResolution (assuming it is at the lowest priority) to fix potential crashes
constant u32 global.dynamic_objects.array_newstartloc = 0x8ae380

//# address-hook(0x01040c) end(0x01041c)
function void AddAsDynamicObject()
{
	if (global.dynamic_objects.size_new < 0x7e)
	{
		global.dynamic_objects.size_new += 2
		u16[global.dynamic_objects.array_newstartloc + global.dynamic_objects.size_new] = A0.u16
	}
}

//# address-hook(0x006c2c) end(0x006c32)
function void ResetDynamicObjectList()
{
	global.dynamic_objects.size_new = 0
}

//# address-hook(0x00ff06) end(0x00ff5e)
function void Character.CheckCollisionsWithDynamicObjects_partial()
{
#if STANDALONE
	// Bounding box of player
	if (DEBUG_DYNAMIC_COLLISIONS)
		debugDrawRect(D2.u16, D3.u16, D4.u16, D5.u16, 0x8000ff00)
#endif

	u16 numObjects = global.dynamic_objects.size_new		// Actually it's twice the number of dynamic objects
	A4 = addressof(global.dynamic_objects.size_new) + 2		// Resulting address: 0x8ae382
	while (numObjects != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		// Offset into a list of hitbox sizes (the list looks a bit random)
		u16 offset = objA1.collision_attributes
		if (offset != 0)
		{
			// Targets:
			//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4
			//  - 0x14 x 0x14  -> (offset & collision_attributes.size) = collision.size.20x20
			//  - 0x0c x 0x14  -> (offset & collision_attributes.size) = collision.size.12x20
			//  - 0x14 x 0x0c  -> (offset & collision_attributes.size) = collision.size.20x12
			//  - 0x04 x 0x10  -> (offset & collision_attributes.size) = collision.size.4x16
			//  - 0x0c x 0x12  -> (offset & collision_attributes.size) = collision.size.12x18
			//  - 0x10 x 0x10  -> (offset & collision_attributes.size) = collision.size.16x16
			//  - 0x06 x 0x06  -> (offset & collision_attributes.size) = collision.size.6x6
			//  - 0x18 x 0x0c  -> (offset & collision_attributes.size) = collision.size.24x12
			//  - 0x0c x 0x10  -> (offset & collision_attributes.size) = collision.size.12x16
			//  - 0x10 x 0x08  -> (offset & collision_attributes.size) = collision.size.16x8
			//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8
			//  - 0x14 x 0x10  -> (offset & collision_attributes.size) = collision.size.20x16
			//  - 0x14 x 0x08  -> (offset & collision_attributes.size) = collision.size.20x8
			//  - 0x0e x 0x0e  -> (offset & collision_attributes.size) = collision.size.14x14
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24
			//  - 0x28 x 0x10  -> (offset & collision_attributes.size) = collision.size.40x16
			//  - 0x10 x 0x18  -> (offset & collision_attributes.size) = collision.size.16x24
			//  - 0x08 x 0x10  -> (offset & collision_attributes.size) = collision.size.8x16
			//  - 0x20 x 0x70  -> (offset & collision_attributes.size) = collision.size.32x112
			//  - 0x40 x 0x20  -> (offset & collision_attributes.size) = collision.size.64x32
			//  - 0x80 x 0x20  -> (offset & collision_attributes.size) = collision.size.128x32
			//  - 0x20 x 0x20  -> (offset & collision_attributes.size) = collision.size.32x32
			//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8_2
			//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4_2
			//  - 0x20 x 0x08  -> (offset & collision_attributes.size) = collision.size.32x8
			//  - 0x0c x 0x0c  -> (offset & collision_attributes.size) = collision.size.12x12
			//  - 0x08 x 0x04  -> (offset & collision_attributes.size) = collision.size.8x4
			//  - 0x18 x 0x04  -> (offset & collision_attributes.size) = collision.size.24x4
			//  - 0x28 x 0x04  -> (offset & collision_attributes.size) = collision.size.40x4
			//  - 0x04 x 0x08  -> (offset & collision_attributes.size) = collision.size.4x8
			//  - 0x04 x 0x18  -> (offset & collision_attributes.size) = collision.size.4x24
			//  - 0x04 x 0x28  -> (offset & collision_attributes.size) = collision.size.4x40
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_2
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_3
			//  - 0x0c x 0x18  -> (offset & collision_attributes.size) = collision.size.12x24
			//  - 0x48 x 0x08  -> (offset & collision_attributes.size) = collision.size.72x8
			//  - 0x18 x 0x28  -> (offset & collision_attributes.size) = collision.size.24x40
			//  - 0x10 x 0x04  -> (offset & collision_attributes.size) = collision.size.16x4
			//  - 0x20 x 0x02  -> (offset & collision_attributes.size) = collision.size.32x2
			//  - 0x10 x 0x1c  -> (offset & collision_attributes.size) = collision.size.16x28
			//  - 0x0c x 0x24  -> (offset & collision_attributes.size) = collision.size.12x36
			//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2
			//  - 0x04 x 0x40  -> (offset & collision_attributes.size) = collision.size.4x64
			//  - 0x18 x 0x40  -> (offset & collision_attributes.size) = collision.size.24x64
			//  - 0x20 x 0x10  -> (offset & collision_attributes.size) = collision.size.32x16
			//  - 0x1c x 0x14  -> (offset & collision_attributes.size) = collision.size.28x20
			//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2_2
			//  - 0x10 x 0x01  -> (offset & collision_attributes.size) = collision.size.16x1
			//  - 0x02 x 0x08  -> (offset & collision_attributes.size) = collision.size.2x8
			//  - 0x10 x 0x40  -> (offset & collision_attributes.size) = collision.size.16x64
			//  - 0x0c x 0x04  -> (offset & collision_attributes.size) = collision.size.12x4
			//  - 0x08 x 0x0c  -> (offset & collision_attributes.size) = collision.size.8x12
			//  - 0x28 x 0x20  -> (offset & collision_attributes.size) = collision.size.40x32
			//  - 0x40 x 0x02  -> (offset & collision_attributes.size) = collision.size.64x2
			//  - 0x60 x 0x02  -> (offset & collision_attributes.size) = collision.size.96x2
			//  - 0x28 x 0x28  -> (offset & collision_attributes.size) = collision.size.40x40
			A2 = 0x00ff62 + (offset & collision_attributes.size) * 2
			s16 hitbox.x = u8[A2]
			s16 hitbox.y = u8[A2+1]

			u16 px = objA1.position.x.u16 - hitbox.x
			u16 py = objA1.position.y.u16 - hitbox.y
			u16 sx = hitbox.x * 2
			u16 sy = hitbox.y * 2

		#if STANDALONE
			if (DEBUG_DYNAMIC_COLLISIONS)
			{
				if ((offset & collision_attributes.flags) == collision.flag.ITEM)
					debugDrawRect(px, py, sx, sy, 0x8000ff00)
				else if ((offset & collision_attributes.flags) == collision.flag.SPECIAL)
					debugDrawRect(px, py, sx, sy, 0x80ff0000)
				else if ((offset & collision_attributes.flags) == collision.flag.THREAT)
					debugDrawRect(px, py, sx, sy, 0x800000ff)
				else
					debugDrawRect(px, py, sx, sy, 0x80ff00ff)
			}
		#endif

			if (checkBoxOverlap(D2.u16, D3.u16, D4.u16, D5.u16, px, py, sx, sy))
			{
				// Collision found
				Character.OnCollisionWithDynamicObject()
				return
			}
		}

		numObjects -= 2
	}
}

//# address-hook(0x01041e) end(0x0104e8)
function void UpdateShieldDeflecting()
{
	// Any shield active?
	if ((char.bonus_effect & char.bonus.ALL_SHIELDS) == 0)
		return

	// Bounding box of shield, or projectile deflection range
	D2.u16 = char.position.x.u16 - 0x18
	D3.u16 = char.position.y.u16 - 0x18
	D4.u16 = 0x30
	D5.u16 = 0x30

#if STANDALONE
	if (DEBUG_DYNAMIC_COLLISIONS >= 2)
		debugDrawRect(D2.u16, D3.u16, D4.u16, D5.u16, 0x8000ffff)
#endif

	u16 numObjects = global.dynamic_objects.size_new		// Actually it's twice the number of dynamic objects
	A4 = addressof(global.dynamic_objects.size_new) + 2		// Resulting address: 0x8ae382
	while (numObjects != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		// Check for deflectable object
		u8 collisionFlags = (objA1.collision_attributes & collision_attributes.flags)
		if (collisionFlags == collision.flag.THREAT)
		{
			// Offset into a list of hitbox sizes?
			u16 offset = (objA1.collision_attributes & collision_attributes.size)
			if (offset != 0)
			{
				// Targets:
				//  - 0x04 x 0x04  -> offset = collision.size.4x4
				//  - 0x14 x 0x14  -> offset = collision.size.20x20
				//  - 0x0c x 0x14  -> offset = collision.size.12x20
				//  - 0x14 x 0x0c  -> offset = collision.size.20x12
				//  - 0x04 x 0x10  -> offset = collision.size.4x16
				//  - 0x0c x 0x12  -> offset = collision.size.12x18
				//  - 0x10 x 0x10  -> offset = collision.size.16x16
				//  - 0x06 x 0x06  -> offset = collision.size.6x6
				//  - 0x18 x 0x0c  -> offset = collision.size.24x12
				//  - 0x0c x 0x10  -> offset = collision.size.12x16
				//  - 0x10 x 0x08  -> offset = collision.size.16x8
				//  - 0x08 x 0x08  -> offset = collision.size.8x8
				//  - 0x14 x 0x10  -> offset = collision.size.20x16
				//  - 0x14 x 0x08  -> offset = collision.size.20x8
				//  - 0x0e x 0x0e  -> offset = collision.size.14x14
				//  - 0x18 x 0x18  -> offset = collision.size.24x24
				//  - 0x28 x 0x10  -> offset = collision.size.40x16
				//  - 0x10 x 0x18  -> offset = collision.size.16x24
				//  - 0x08 x 0x10  -> offset = collision.size.8x16
				//  - 0x20 x 0x70  -> offset = collision.size.32x112
				//  - 0x40 x 0x20  -> offset = collision.size.64x32
				//  - 0x80 x 0x20  -> offset = collision.size.128x32
				//  - 0x20 x 0x20  -> offset = collision.size.32x32
				//  - 0x08 x 0x08  -> offset = collision.size.8x8_2
				//  - 0x04 x 0x04  -> offset = collision.size.4x4_2
				//  - 0x20 x 0x08  -> offset = collision.size.32x8
				//  - 0x0c x 0x0c  -> offset = collision.size.12x12
				//  - 0x08 x 0x04  -> offset = collision.size.8x4
				//  - 0x18 x 0x04  -> offset = collision.size.24x4
				//  - 0x28 x 0x04  -> offset = collision.size.40x4
				//  - 0x04 x 0x08  -> offset = collision.size.4x8
				//  - 0x04 x 0x18  -> offset = collision.size.4x24
				//  - 0x04 x 0x28  -> offset = collision.size.4x40
				//  - 0x18 x 0x18  -> offset = collision.size.24x24_2
				//  - 0x18 x 0x18  -> offset = collision.size.24x24_3
				//  - 0x0c x 0x18  -> offset = collision.size.12x24
				//  - 0x48 x 0x08  -> offset = collision.size.72x8
				//  - 0x18 x 0x28  -> offset = collision.size.24x40
				//  - 0x10 x 0x04  -> offset = collision.size.16x4
				//  - 0x20 x 0x02  -> offset = collision.size.32x2
				//  - 0x10 x 0x1c  -> offset = collision.size.16x28
				//  - 0x0c x 0x24  -> offset = collision.size.12x36
				//  - 0x10 x 0x02  -> offset = collision.size.16x2
				//  - 0x04 x 0x40  -> offset = collision.size.4x64
				//  - 0x18 x 0x40  -> offset = collision.size.24x64
				//  - 0x20 x 0x10  -> offset = collision.size.32x16
				//  - 0x1c x 0x14  -> offset = collision.size.28x20
				//  - 0x10 x 0x02  -> offset = collision.size.16x2_2
				//  - 0x10 x 0x01  -> offset = collision.size.16x1
				//  - 0x02 x 0x08  -> offset = collision.size.2x8
				//  - 0x10 x 0x40  -> offset = collision.size.16x64
				//  - 0x0c x 0x04  -> offset = collision.size.12x4
				//  - 0x08 x 0x0c  -> offset = collision.size.8x12
				//  - 0x28 x 0x20  -> offset = collision.size.40x32
				//  - 0x40 x 0x02  -> offset = collision.size.64x2
				//  - 0x60 x 0x02  -> offset = collision.size.96x2
				//  - 0x28 x 0x28  -> offset = collision.size.40x40
				A2 = 0x00ff62 + offset * 2
				s16 hitbox.x = u8[A2]
				s16 hitbox.y = u8[A2+1]

				u16 px = objA1.position.x.u16 - hitbox.x
				u16 py = objA1.position.y.u16 - hitbox.y
				u16 sx = hitbox.x * 2
				u16 sy = hitbox.y * 2

			#if STANDALONE
				if (DEBUG_DYNAMIC_COLLISIONS >= 2)
					debugDrawRect(px, py, sx, sy, 0x8000ffff)
			#endif

				if (checkBoxOverlap(D2.u16, D3.u16, D4.u16, D5.u16, px, py, sx, sy))
				{
					if (u8[A1 + 0x2b] & char.bonus.DEFLECTABLE)
					{
						deflectProjectile()
						return
					}
				}
			}
		}

		numObjects -= 2
	}
}

function void Character.clearEnemiesOnScreen(u16 minY)
{
	push(A4)
	push(A3)
	push(A2)

	// Go through all the badniks to destroy
	D6.u16 = global.dynamic_objects.size_new
	A4 = addressof(global.dynamic_objects.size_new) + 2		// Resulting address: 0x8ae382
	while (D6.u16 != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		D0 = objA1.collision_attributes
		if (D0.u8 != 0)
		{
		#if STANDALONE
			// Assuming minY is only set for lightning shield touching water
			if (minY > 0)
			{
				if (objA1.position.y.u16 >= minY)
				{
					fn01050c()
				}
			}
			else
		#endif
			{
				fn01050c()
			}
		}
		D6.u16 -= 2
	}

	A2 = pop()
	A3 = pop()
	A4 = pop()
}

//# address-hook(0x02d638) end(0x02d68a)
function void fn02d638()
{
	global.dynamic_objects.size_new = 0
	if ((objA0.animation.sprite & 0x01) == 0)
	{
		D0.u8 = (control.pad1.pressed | control.pad2.pressed) & (CONTROL_START | CONTROL_ABC)
		if (D0.u8 == 0 && u16[A0 + 0x24] != 0)
		{
			--u16[A0 + 0x24]
		}
		else
		{
			if (global.time_over)
			{
				checkpoint.time = 0
				level.restart = 1

			#if STANDALONE
				Standalone.onDeath()
			#endif
			}
			else
			{
				global.game_mode = (continues_counter == 0) ? 0 : 0x14		// Initialization/Continue Screen
			}
		}
	}
	DrawObject()
}

//# address-hook(0x01a3fe) end(0x01a432)
function void fn01a3fe()
{
	D1 = 0

	// Go through all the badniks to destroy
	D6.u16 = global.dynamic_objects.size_new
	A4 = addressof(global.dynamic_objects.size_new) + 2		// Resulting address: 0x8ae382
	if (D6.u16 != 0)
	{
		u8[0xfffff66c] += 2
		if (u8[0xfffff66c] >= D6.u8)
		{
			u8[0xfffff66c] = 0
		}

		D0 = u8[0xfffff66c]
		D6.u16 -= D0.u16
		A4 += D0.s16
		while (D6.u16 != 0)
		{
			// Get address of dynamic object
			A1 = 0xffff0000 + u16[A4]
			A4 += 2

			D0.u8 = objA1.collision_attributes
			if (D0.u8 != 0)
			{
				fn01a434()
			}
			D6.u16 -= 2
		}
	}
}

////////////////
// Draw level //
////////////////

//# address-hook(0x04ed90) end(0x04edb0)
function void LoadTileContentDefault()
{
	A6 = addressof(camera.foreground.x)			// Address: 0xffffee80
	A5 = addressof(camera.foreground.x.old)		// Address: 0xffffee88
	D1.u16 = camera.foreground.y.u16
	D6 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	LoadTileContentInDirX()

	A6 = addressof(camera.foreground.y)			// Address: 0xffffee84
	A5 = addressof(camera.foreground.y.old)		// Address: 0xffffee8a
	D1.u16 = camera.foreground.x.u16
	D6 = (getScreenWidth() + 31) / 16
	LoadTileContentInDirY()
}

//# address-hook(0x04edb4) end(0x04edd4)
function void UpdateBackgroundTiles.General()
{
	A6 = addressof(camera.background.x)			// Address: 0xffffee8c
	A5 = addressof(camera.background.x.old)		// Address: 0xffffee94
	D1.u16 = camera.background.y.u16
	D6 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	LoadTileContentInDirX()

	A6 = addressof(camera.background.y)			// Address: 0xffffee90
	A5 = addressof(camera.background.y.old)		// Address: 0xffffee96
	D1.u16 = camera.background.x.u16
	D6 = (getScreenWidth() + 31) / 16
	LoadTileContentInDirY()
}

//# address-hook(0x04ead8) end(0x04eb20)
function void LoadTileContentInDirY()
{
	u16 oldOffset = u16[A5]
	u16 newOffset = u16[A6] & level.height.tilemask
	u16[A5] = newOffset

	// Anything to do?
	s16 diff = oldOffset - newOffset
	if (diff == 0)
		return

	// Note that there are cases where s8(diff) is actually zero here, though diff is not (e.g. LBZ1 cutscene before boss)
	if (s8(diff) >= 0)
	{
		// Screen moved up
		D0.u16 = newOffset
	}
	else
	{
		// Screen moved down
		diff = -diff
		D0.u16 = (oldOffset + getScreenHeight() + 16) & level.height.tilemask		// formerly 0xf0 = 240 = screen height + 16
	}
	u8[0xffffeea4] = ((diff & 0x30) != 0x10) ? 0xff : 0x00

	//debugLog(stringformat("LoadTileContentInDirY (%d lines): posX=0x%04x, posY=0x%04x, rows=0x%02x", u8[0xffffeea4] ? 2 : 1, D0, D1, D6.u16))

	u32 backupD1 = D1
	u32 backupD6 = D6
	LoadTileContentSingleLine()
	D1 = backupD1
	D6 = backupD6

	if (u8[0xffffeea4] != 0)
	{
		D0.u16 = (D0.u16 + 0x10) & level.height.tilemask
		LoadTileContentSingleLine()
	}
}

//# address-hook(0x04eb22) end(0x04eb68)
function void fn04eb22()
{
	// Updates background sprite patterns in some zones (e.g. AIZ 1 and MHZ)
	u16 oldOffset = u16[A5]
	u16 newOffset = u16[A6] & level.height.tilemask
	u16[A5] = newOffset

	// Anything to do?
	s16 diff = oldOffset - newOffset
	if (diff == 0)
		return

	// Note that there are cases where s8(diff) is actually zero here, though diff is not
	if (s8(diff) >= 0)
	{
		// Screen moved up
		D0.u16 = newOffset
	}
	else
	{
		// Screen moved down
		diff = -diff
		D0.u16 = (oldOffset + getScreenHeight() + 16) & level.height.tilemask		// formerly 0xf0 = 240 = screen height + 16
		D1 = (D1 << 16) + (D1 >> 16)
	}
	u8[0xffffeea4] = ((diff & 0x30) != 0x10) ? 0xff : 0x00

	u16 backupD1 = D1.u16
	u16 backupD6 = D6.u16
	LoadTileContentSingleLine()
	D1.u16 = backupD1
	D6.u16 = backupD6

	if (u8[0xffffeea4] != 0)
	{
		D0.u16 = (D0.u16 + 0x10) & level.height.tilemask
		LoadTileContentSingleLine()
	}
}

//# address-hook(0x04ee20) end(0x04ee82)
function void fn04ee20()
{
	D1.u16 = D6.u16
	while (true)
	{
		D6.u16 -= u16[A4]
		A4 += 2
		if (D6.s16 < 0)
			break

		D0.u16 = u16[A6] & 0xfff0
		u16[A6 + 2] = D0.u16
		A6 += 4
		--D5.u16
	}

	D6.s16 = -D6.s16
	D6.u16 >>= 4
	D4 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	D4.u16 -= D6.u16
	if (D4.s16 < 0)
	{
		D4 = 0
		D6 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	}

	while (true)
	{
		u16 backupD1 = D1.u16
		u16 backupD4 = D4.u16
		u16 backupD5 = D5.u16
		u16 backupD6 = D6.u16
		u32 backupA4 = A4
		u32 backupA6 = A6

		A5 = A6 + 2
		LoadTileContentInDirX()

		A4 = backupA4
		A6 = backupA6
		D1.u16 = backupD1
		D4.u16 = backupD4
		D5.u16 = backupD5
		D6.u16 = backupD6

		A6 += 4
		if (D4.u16 == 0)
			break

		D6.u16 <<= 4
		D1.u16 += D6.u16
		--D5.u16
		D6.u16 = u16[(A4+=2)-2] >> 4
		D0.u16 = D4.u16
		D4.u16 -= D6.u16
		if (D4.s16 < 0)
		{
			D6.u16 = D0.u16
			D4 = 0
		}
	}

	while (true)
	{
		--D5.u16
		if (D5.u16 == 0)
			break

		D0.u16 = u16[(A6+=2)-2] & 0xfff0
		u16[(A6+=2)-2] = D0.u16
	}
}

////////////////
// Draw Rings //
////////////////

//# address-hook(0x00e8be) end(0x00e940)
function void InitStaticRings()
{
	rings.update_routine += 2
	fn00eb1a()

	if (global.zone == 0x14)	// Glowing Spheres bonus stage
	{
		rings.update_routine += 2

		A1 = rings.around.first
		A2 = 0xffff8600
		D4.u16 = camera.position.y.u16 - 8
		if (D4.s16 <= 0)
			D1 = 1

		while (D4.u16 > u16[A1 + 2])
		{
			A1 += 4
			A2 += 2
		}
		rings.around.first = A1
		rings.around.first.state = A2.u16
		D4.u16 += getScreenHeight() + 16		// formerly 0xf0 = 240 = screen height + 16

		while (D4.u16 > u16[A1 + 2])
		{
			A1 += 4
		}
		rings.around.last = A1
	}
	else
	{
		A1 = rings.around.first
		A2 = 0xffffe700
		D4.u16 = camera.position.x.u16 - 8
		if (D4.s16 <= 0)
			D4 = 1

		while (D4.u16 > u16[A1])
		{
			A1 += 4
			A2 += 2
		}
		rings.around.first = A1
		rings.around.first.state = A2.u16
		D4.u16 += 0x150

		while (D4.u16 > u16[A1])
		{
			A1 += 4
		}
		rings.around.last = A1
	}
}

//# address-hook(0x00eb86) end(0x00ebec)
function void RenderStaticRings()
{
	A0 = rings.around.first
	u32 numRings = (rings.around.last - rings.around.first) / 4
	if (numRings != 0)
	{
		A4 = 0xffff0000 + rings.around.first.state
		A1 = 0x00ebee
		D5.u16 = getScreenHeight() + 16		// formerly 0xf0 = 240 = screen height + 16
		u16 camera_x = u16[A3]		// Usually camera.foreground.x
		u16 camera_y = u16[A3+4]	// Usually camera.foreground.y

		while (numRings > 0)
		{
			u16 ringAnimationState = u16[A4]
			if (ringAnimationState != 0xffff)
			{
				D1.u16 = (u16[A0+2] - camera_y + 8) & level.height.bitmask
				if (D1.u16 < D5.u16)
				{
					D1.u16 += 0x78
					D0.u16 = u16[A0] - camera_x + 0x80

					u8 animFrame = ringAnimationState & 0xff
					if (animFrame == 0)
					{
						// For non-collected rings, use rotating animation
						animFrame = static_rings.animframe
					}
					u32 src = A1 + animFrame * 8

					u16 px = u16[src + 6] + D0.u16
					u16 py = u16[src + 0] + D1.u16
					u8 size = u8[src + 3]
					u16 index = u16[src + 4]

				#if STANDALONE
					if ((ringAnimationState & 0xff) == 0)
					{
						// Custom smoother ring animations
						animFrame = ((static_rings.animframe * 8 + 7 - static_rings.animtimer) / 4) % 8
						u64 key = stringformat("ring_0%d", animFrame)
						u16 x = D0.u16 - 0x80
						u16 y = D1.u16 - 0x80
						Renderer.drawCustomSprite(key, x, y, 0x00, 0, 0xa000)
					}
					else
					{
						Renderer.drawVdpSprite(px - 0x80, py - 0x80, size, index, 0xc000)
					}
				#endif

					u16[A6 + 0] = py
					 u8[A6 + 2] = size
					u16[A6 + 4] = index
					u16[A6 + 6] = px
					A6 += 8
					--D7.u16
				}
			}
			A4 += 2
			A0 += 4
			--numRings
		}
	}
}

//////////////
// Draw HUD //
//////////////

// Render the life counter at an appropriate height.
// Also prevent debug mode from using VRAM to draw its HUD information.
//# address-hook(0x00db44) end(0x00dbb2)
function void RenderHUD()
{
#if STANDALONE
	if (DEBUG_DISABLE_HUD)
		return
#endif

	s16 baseX = global.level_started
	if (baseX < 0)
	{
		baseX += 8
		global.level_started = baseX
	}
	baseX += 0x0f
	s16 baseY = 0x08
	u16 renderQueue = 0xe000

	bool isBonusStage = (global.zone >= 0x13 && global.zone <= 0x15)
#if STANDALONE
//	if (!debug_mode.state)
//	{
		if (!isBonusStage)
		{
			// Score
			HUD.drawSprite("hud_text_score", baseX, baseY, renderQueue)
			++renderQueue
			HUD.drawNumber("hud_digit_%d", player.score * 10, baseX + 0x58, baseY, renderQueue)
			++renderQueue

			// Time
			{
				bool show = (timer.minutes < 9 || isBonusStage || (level.framecounter & 0x08) || Game.getSetting(SETTING_INFINITE_TIME))
				HUD.drawSprite(show ? "hud_text_time" : "hud_text_time_red", baseX, baseY + 0x10, renderQueue)
				++renderQueue

				// Unfortunately, the time progress is done later inside the frame, so we don't have the right value in "timer.frames" yet
				//  -> If the conditions for time progress are met, add one and everything will be alright
				u16 minutes = timer.minutes
				u16 seconds = timer.seconds
				u16 frames = timer.frames
				if (hud.dirty.timer && !global.game.paused && timer.alldata < 0x93b3b)	// That is 9:59 and 59 frames
				{
					++frames
					seconds += (frames / 60)
					minutes += (seconds / 60)
					frames %= 60
					seconds %= 60
				}
				u16 centiseconds = (frames * 99 + 30) / 59

				u16 px = (minutes >= 10) ? (baseX + 8) : baseX
				if (Game.getSetting(SETTING_EXTENDED_HUD))
				{
					if (minutes >= 10)
						HUD.drawDigit(minutes / 10, px + 0x20, baseY + 0x10, renderQueue)
					HUD.drawDigit(minutes % 10, px + 0x28, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_minutes", px + 0x30, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds / 10, px + 0x38, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds % 10, px + 0x40, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_seconds", px + 0x48, baseY + 0x10, renderQueue)
					HUD.drawDigit(centiseconds / 10, px + 0x50, baseY + 0x10, renderQueue)
					if (minutes < 10)
						HUD.drawDigit(centiseconds % 10, px + 0x58, baseY + 0x10, renderQueue)
				}
				else
				{
					if (minutes >= 10)
						HUD.drawDigit(minutes / 10, px + 0x20, baseY + 0x10, renderQueue)
					HUD.drawDigit(minutes % 10, px + 0x28, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_colon", px + 0x30, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds / 10, px + 0x38, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds % 10, px + 0x40, baseY + 0x10, renderQueue)
				}
				++renderQueue
			}
		}

		// Rings
		{
			u16 py = (isBonusStage) ? baseY : baseY + 0x20
			bool show = (ring_counter != 0 || (level.framecounter & 0x08))
			HUD.drawSprite(show ? "hud_text_rings" : "hud_text_rings_red", baseX, py, renderQueue)
			++renderQueue

			u16 px = baseX + (!isBonusStage && Game.getSetting(SETTING_EXTENDED_HUD) ? 0x58 : 0x40)
			for (u32 value = ring_counter;;)
			{
				HUD.drawDigit(value % 10, px, py, renderQueue)
				px -= 8
				value /= 10
				if (value == 0)
					break
			}
			++renderQueue
		}

		// Lives (not visible in Time Attack or with infinite lives setting)
		if (!Game.isTimeAttack() && !Game.getSetting(SETTING_INFINITE_LIVES))
		{
			bool useMobilePosition = HUD.useMobileLivesDisplay()
			u16 px = useMobilePosition ? (getScreenWidth() - baseX - 0x30) : baseX
			u16 py = useMobilePosition ? baseY : getScreenHeight() - 24 // formerly 200

			HUD.drawSprite(getCharacterLivesIcon(getMainCharacter()), px, py, renderQueue)
			++renderQueue

			if (lives_counter >= 10)
				HUD.drawSmallDigit(u16((lives_counter / 10) % 10), px + 0x20, py + 8, renderQueue)
			HUD.drawSmallDigit(u16(lives_counter % 10), px + 0x28, py + 8, renderQueue)
		}
//	}
//	else
#endif
/*
	{
		D4 = (isBonusStage) ? 8 : 0

		if ((level.framecounter & 0x08) == 0)
		{
			if (ring_counter == 0)
			{
				D4 += 2		// Set rings HUD text to flicker
			}
			if (timer.minutes == 9 && !isBonusStage)
			{
				D4 += 4		// Set timer HUD text to flicker
			}
		}

		// Targets:
		//  - 0x00dbc2	-> D4.u16 = 0x00		// Complete HUD text
		//  - 0x00dc00	-> D4.u16 = 0x02		// HUD with rings text flickering
		//  - 0x00dc32	-> D4.u16 = 0x04		// HUD with time text flickering
		//  - 0x00dc6a	-> D4.u16 = 0x06		// HUD with both rings and time flickering
		//  - 0x00dc96	-> D4.u16 = 0x08		// Bonus stage HUD
		//  - 0x00dcb6	-> D4.u16 = 0x0a		// Bonus stage HUD with rings text flickering
		A1 = tableLookupAddress(0x00dbb6, D4.u16)

		D4.s16 = u16[A1] - 1
		D0.s16 = baseX + 0x80
		D1.u16 = 0x0108
		D5.u16 = 0x86ca
		A1 += 2
		if (D4.s16 >= 0)
		{
			writeToSpriteTable(renderQueue)
		}
	}
*/
}

// Do not update HUD elements in VRAM. We are using that VRAM for shields,
// super sparks, and GAME/TIME OVER while AIR draws the HUD as images.
function void refreshHudDisplayShared(u8 numDigits, bool showAllDigits)
{
	return
/*	
	u32 decimal = pow(10, numDigits - 1)

	while (decimal > 0)
	{
		u8 digit = D1 / decimal
		D1 %= decimal

		if (digit != 0)
		{
			// From now on, show all digits (don't skip leading zeroes any more)
			showAllDigits = true
		}

		if (showAllDigits)
		{
			// Location of sprite for this digit
			A3 = 0x00e18a + digit * 0x40

			u32 vramAddress = VDPHelper.getVRAMAddressFromWriteCode(D0)
			VDP.setupVRAMWrite(vramAddress)
			VDP.copyToVRAM(A3, 0x40)
		}

		D0 += 0x400000
		decimal /= 10
	}
*/
}

//# address-hook(0x00e11e) end(0x00e188)
function void UpdateHudLivesDisplay()
{
	return
/*
	u16 vramAddress = 0xfba0
	u16 number = lives_counter
	u8 digit = 10

	while (digit > 0)
	{
		u8 counter = 0
		while (number >= digit)
		{
			number -= digit
			++counter
		}

		VDP.setupVRAMWrite(vramAddress)
		if (counter > 0 || digit == 1)
		{
			A3 = 0x00e48a + counter * 0x20
			VDP.copyToVRAM(A3, 0x20)
		}
		else
		{
			VDP.zeroVRAM(0x20)
		}

		vramAddress += 0x40
		digit /= 10
	}
*/
}

//# address-hook(0x00defc) end(0x00df52)
function void DebugModePositionDisplay()
{
	return
/*
	// Initialize direct VRAM write
	VDP.setupVRAMWrite(0xdc40)

	D1 = (u32(camera.position.x.u16) << 16) + u16[0xffffb000 + 0x10]
	fn00df1c()

	D1 = (u32(camera.position.y.u16) << 16) + u16[0xffffb000 + 0x14]
	fn00df1c()
*/
}

//# address-hook(0x00de88) end(0x00de9a)
function void ResetRingsDisplay()
{
	return
/*
	// Initialize direct VRAM write
	VDP.setupVRAMWrite(0xdf40)
	A2 = 0x00def8
	D2.u16 = 2
	fn00debe()
*/
}

//# address-hook(0x00de9c) end(0x00deba)
function void ResetScoreDisplay()
{
	return
/*
	UpdateHudLivesDisplay()
	if (competition_mode.active)
		return

	// Initialize direct VRAM write
	VDP.setupVRAMWrite(0xdc40)
	A2 = 0x00deec
	D2.u16 = 14
	fn00debe()
*/
}
